<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design Patterns on wlsc</title><link>https://wlsc.de/tags/design-patterns/</link><description>Recent content in Design Patterns on wlsc</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 05 Sep 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://wlsc.de/tags/design-patterns/index.xml" rel="self" type="application/rss+xml"/><item><title>Double-Checked Locking Pattern with Lazy Singletone Initialization</title><link>https://wlsc.de/posts/2016-09-05-double-checked-locking-pattern-with-lazy-singletone-initialization/</link><pubDate>Mon, 05 Sep 2016 00:00:00 +0000</pubDate><guid>https://wlsc.de/posts/2016-09-05-double-checked-locking-pattern-with-lazy-singletone-initialization/</guid><description>&lt;p&gt;In the real world of multicore processors, we have to write multi-threaded applications that would use all cores
efficiently. This is very practical, when it comes to high-loaded servers (with a high amount of users trying to access
service at the same time). For instance, after you have successfully introduced the new functionality on your web
service or fixed some bugs, your first intuition would be to release the new version as soon as possible. At this point,
when your users start to access your web service simultaneously, a situation may arise, when two or more users will
initialize the same singleton or field value more than once. This is not a favorable type of scenario. It is also the
main reason your applications should be ready to initialize its singletons (and not only) properly!&lt;/p&gt;</description></item></channel></rss>